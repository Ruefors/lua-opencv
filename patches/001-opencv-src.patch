diff --git a/cmake/templates/OpenCVConfig.cmake.in b/cmake/templates/OpenCVConfig.cmake.in
index 2e9022a355..d4333754b4 100644
--- a/cmake/templates/OpenCVConfig.cmake.in
+++ b/cmake/templates/OpenCVConfig.cmake.in
@@ -122,7 +122,7 @@ endforeach()
 unset(__d)
 
 
-if(NOT TARGET opencv_core)
+if((NOT TARGET opencv_core) AND (NOT TARGET opencv_world))
   include(${CMAKE_CURRENT_LIST_DIR}/OpenCVModules${OpenCV_MODULES_SUFFIX}.cmake)
 endif()
 
diff --git a/modules/core/include/opencv2/core/mat.hpp b/modules/core/include/opencv2/core/mat.hpp
index c4c6ff6d78..c6970bc63a 100644
--- a/modules/core/include/opencv2/core/mat.hpp
+++ b/modules/core/include/opencv2/core/mat.hpp
@@ -2648,6 +2648,10 @@ public:
 protected:
 };
 
+inline bool operator== (const UMat& a, const UMat& b) {
+    return &a == &b;
+}
+
 
 /////////////////////////// multi-dimensional sparse matrix //////////////////////////
 
@@ -3601,6 +3605,7 @@ public:
     MatExpr diag(int d = 0) const;
     MatExpr operator()( const Range& rowRange, const Range& colRange ) const;
     MatExpr operator()( const Rect& roi ) const;
+    explicit operator bool() const;
 
     MatExpr t() const;
     MatExpr inv(int method = DECOMP_LU) const;
diff --git a/modules/core/src/matrix_expressions.cpp b/modules/core/src/matrix_expressions.cpp
index 44ac8f1713..33a40fbd3b 100644
--- a/modules/core/src/matrix_expressions.cpp
+++ b/modules/core/src/matrix_expressions.cpp
@@ -648,6 +648,11 @@ MatExpr MatExpr::operator()( const Rect& roi ) const
     return e;
 }
 
+MatExpr::operator bool() const
+{
+    return countNonZero(*this) == ((Mat)*this).total();
+}
+
 Mat MatExpr::cross(const Mat& m) const
 {
     return ((Mat)*this).cross(m);
diff --git a/modules/gapi/include/opencv2/gapi/garray.hpp b/modules/gapi/include/opencv2/gapi/garray.hpp
index b6aa715518..b5e4958217 100644
--- a/modules/gapi/include/opencv2/gapi/garray.hpp
+++ b/modules/gapi/include/opencv2/gapi/garray.hpp
@@ -317,6 +317,10 @@ namespace detail
         const void *ptr() const { return m_ref->ptr(); }
     };
 
+    inline bool operator== (const VectorRef& a, const VectorRef& b) {
+        return &a == &b;
+    }
+
     // Helper (FIXME: work-around?)
     // stripping G types to their host types
     // like cv::GArray<GMat> would still map to std::vector<cv::Mat>
diff --git a/modules/gapi/include/opencv2/gapi/gopaque.hpp b/modules/gapi/include/opencv2/gapi/gopaque.hpp
index 1d12f127da..e1228bd2a9 100644
--- a/modules/gapi/include/opencv2/gapi/gopaque.hpp
+++ b/modules/gapi/include/opencv2/gapi/gopaque.hpp
@@ -302,6 +302,10 @@ namespace detail
             return *this;
         }
     };
+
+    inline bool operator== (const OpaqueRef& a, const OpaqueRef& b) {
+        return &a == &b;
+    }
 } // namespace detail
 
 /** \addtogroup gapi_data_objects
diff --git a/modules/gapi/include/opencv2/gapi/media.hpp b/modules/gapi/include/opencv2/gapi/media.hpp
index 5da8eeab48..a8e3e7d781 100644
--- a/modules/gapi/include/opencv2/gapi/media.hpp
+++ b/modules/gapi/include/opencv2/gapi/media.hpp
@@ -157,6 +157,10 @@ inline cv::MediaFrame cv::MediaFrame::Create(Args&&... args) {
     return cv::MediaFrame(std::move(ptr));
 }
 
+inline bool operator== (const cv::MediaFrame& a, const cv::MediaFrame& b) {
+    return &a == &b;
+}
+
 /**
  * @brief Provides access to the MediaFrame's underlying data.
  *
diff --git a/modules/gapi/include/opencv2/gapi/render/render_types.hpp b/modules/gapi/include/opencv2/gapi/render/render_types.hpp
index 6d70e3a877..5ab54b9e7a 100644
--- a/modules/gapi/include/opencv2/gapi/render/render_types.hpp
+++ b/modules/gapi/include/opencv2/gapi/render/render_types.hpp
@@ -84,6 +84,10 @@ struct GAPI_EXPORTS_W_SIMPLE Text
     /*@{*/
 };
 
+inline bool operator== (const Text& a, const Text& b) {
+    return &a == &b;
+}
+
 /**
  * @brief This structure represents a text string to draw using
  * FreeType renderer.
@@ -119,6 +123,10 @@ struct FText
     /*@{*/
 };
 
+inline bool operator== (const FText& a, const FText& b) {
+    return &a == &b;
+}
+
 /**
  * @brief This structure represents a rectangle to draw.
  *
@@ -156,6 +164,10 @@ struct GAPI_EXPORTS_W_SIMPLE Rect
     /*@{*/
 };
 
+inline bool operator== (const Rect& a, const Rect& b) {
+    return &a == &b;
+}
+
 /**
  * @brief This structure represents a circle to draw.
  *
@@ -197,6 +209,10 @@ struct GAPI_EXPORTS_W_SIMPLE Circle
     /*@{*/
 };
 
+inline bool operator== (const Circle& a, const Circle& b) {
+    return &a == &b;
+}
+
 /**
  * @brief This structure represents a line to draw.
  *
@@ -238,6 +254,10 @@ struct GAPI_EXPORTS_W_SIMPLE Line
     /*@{*/
 };
 
+inline bool operator== (const Line& a, const Line& b) {
+    return &a == &b;
+}
+
 /**
  * @brief This structure represents a mosaicing operation.
  *
@@ -269,6 +289,10 @@ struct GAPI_EXPORTS_W_SIMPLE Mosaic
     /*@{*/
 };
 
+inline bool operator== (const Mosaic& a, const Mosaic& b) {
+    return &a == &b;
+}
+
 /**
  * @brief This structure represents an image to draw.
  *
@@ -301,6 +325,10 @@ struct GAPI_EXPORTS_W_SIMPLE Image
     /*@{*/
 };
 
+inline bool operator== (const Image& a, const Image& b) {
+    return &a == &b;
+}
+
 /**
  * @brief This structure represents a polygon to draw.
  */
@@ -337,6 +365,10 @@ struct GAPI_EXPORTS_W_SIMPLE Poly
     /*@{*/
 };
 
+inline bool operator== (const Poly& a, const Poly& b) {
+    return &a == &b;
+}
+
 using Prim  = util::variant
     < Text
     , FText
diff --git a/modules/gapi/include/opencv2/gapi/rmat.hpp b/modules/gapi/include/opencv2/gapi/rmat.hpp
index 46989191b3..3c0b3bbfde 100644
--- a/modules/gapi/include/opencv2/gapi/rmat.hpp
+++ b/modules/gapi/include/opencv2/gapi/rmat.hpp
@@ -151,6 +151,10 @@ private:
     AdapterP m_adapter = nullptr;
 };
 
+inline bool operator== (const RMat& a, const RMat& b) {
+    return &a == &b;
+}
+
 template<typename T, typename... Ts>
 RMat make_rmat(Ts&&... args) { return { std::make_shared<T>(std::forward<Ts>(args)...) }; }
 /** @} */
diff --git a/modules/gapi/include/opencv2/gapi/util/variant.hpp b/modules/gapi/include/opencv2/gapi/util/variant.hpp
index f412110deb..1fea1b83e0 100644
--- a/modules/gapi/include/opencv2/gapi/util/variant.hpp
+++ b/modules/gapi/include/opencv2/gapi/util/variant.hpp
@@ -132,7 +132,7 @@ namespace util
             static bool help(const Memory lhs, const Memory rhs) {
                 const T& t_lhs = *reinterpret_cast<const T*>(lhs);
                 const T& t_rhs = *reinterpret_cast<const T*>(rhs);
-                return t_lhs == t_rhs;
+                return static_cast<bool>(t_lhs == t_rhs);
             }
         };
 
diff --git a/modules/python/src2/hdr_parser.py b/modules/python/src2/hdr_parser.py
index 710c792179..5a721693bc 100755
--- a/modules/python/src2/hdr_parser.py
+++ b/modules/python/src2/hdr_parser.py
@@ -70,6 +70,29 @@ class CppHeaderParser(object):
 
         return arg_str[npos2+1:npos3].strip(), npos3
 
+    def get_var_list(self, stmt):
+        balance = 0
+        npos = -1
+        while 1:
+            t, npos = self.find_next_token(stmt, ['<', '>', ',', ' '], npos + 1)
+            if npos < 0:
+                print("Error: no matching '>' in the var_list call at %s:%d" % (self.hname, self.lineno))
+                sys.exit(-1)
+            if t == '<':
+                balance += 1
+            elif t == '>':
+                balance -= 1
+            elif balance == 0:
+                break
+
+        var_list = [stmt[:npos]]
+        if t == ',':
+            return [stmt[:npos]] + stmt[npos + 1:].split(",")
+
+        var_list = stmt[npos:].split(",")
+        var_list[0] = stmt[:npos] + var_list[0]
+        return var_list
+
     def parse_arg(self, arg_str, argno):
         """
         Parses <arg_type> [arg_name]
@@ -219,7 +242,7 @@ class CppHeaderParser(object):
         if add_star:
             arg_type += "*"
 
-        arg_type = self.batch_replace(arg_type, [("std::", ""), ("cv::", ""), ("::", "_")])
+        arg_type = self.batch_replace(arg_type, [("std::", ""), ("cv::", "")])
 
         return arg_type, arg_name, modlist, argno
 
@@ -416,11 +439,25 @@ class CppHeaderParser(object):
         npos = decl_str.find("CV_EXPORTS_AS")
         if npos >= 0:
             arg, npos3 = self.get_macro_arg(decl_str, npos)
+            if arg.startswith("get ") or arg.startswith("put ") or arg.startswith("get_default ") or arg.startswith("put_default "):
+                accessor = arg[:3]
+                func_modlist.append("/attr=prop" + accessor)
+                if arg.startswith("get_default ") or arg.startswith("put_default ") : func_modlist.append("/id=DISPID_VALUE")
+                arg = arg[len("get "):] if arg.startswith("get ") or arg.startswith("put ") else arg[len("get_default "):]
+                func_modlist.append("/idlname=" + arg)
+                arg = accessor + "_" + arg
             func_modlist.append("="+arg)
             decl_str = decl_str[:npos] + decl_str[npos3+1:]
         npos = decl_str.find("CV_WRAP_AS")
         if npos >= 0:
             arg, npos3 = self.get_macro_arg(decl_str, npos)
+            if arg.startswith("get ") or arg.startswith("put ") or arg.startswith("get_default ") or arg.startswith("put_default "):
+                accessor = arg[:3]
+                func_modlist.append("/attr=prop" + accessor)
+                if arg.startswith("get_default ") or arg.startswith("put_default ") : func_modlist.append("/id=DISPID_VALUE")
+                arg = arg[len("get "):] if arg.startswith("get ") or arg.startswith("put ") else arg[len("get_default "):]
+                func_modlist.append("/idlname=" + arg)
+                arg = accessor + "_" + arg
             func_modlist.append("="+arg)
             decl_str = decl_str[:npos] + decl_str[npos3+1:]
         npos = decl_str.find("CV_WRAP_PHANTOM")
@@ -645,10 +682,13 @@ class CppHeaderParser(object):
 
         the function will convert "A" to "cv.A" and "f" to "cv.A.f".
         """
-        if not self.block_stack:
-            return name
-        if name.startswith("cv."):
+        if (not self.block_stack) or name.startswith("cv."):
             return name
+        if name.startswith("."):
+            return name[1:]
+        if name.startswith("::"):
+            return name[2:]
+
         qualified_name = (("." in name) or ("::" in name))
         n = ""
         for b in self.block_stack:
@@ -740,7 +780,10 @@ class CppHeaderParser(object):
 
             if stmt.startswith("enum") or stmt.startswith("namespace"):
                 # NB: Drop inheritance syntax for enum
-                stmt = stmt.split(':')[0]
+                if stmt.startswith("enum"):
+                    stmt = stmt.split(':')[0]
+                else:
+                    stmt = stmt.replace("::", ".")
                 stmt_list = stmt.rsplit(" ", 1)
                 if len(stmt_list) < 2:
                     stmt_list.append("<unnamed>")
@@ -776,8 +819,18 @@ class CppHeaderParser(object):
                 var_modlist = []
                 if "CV_PROP_RW" in stmt:
                     var_modlist.append("/RW")
-                stmt = self.batch_replace(stmt, [("CV_PROP_RW", ""), ("CV_PROP", "")]).strip()
-                var_list = stmt.split(",")
+                elif "CV_PROP_W" in stmt:
+                    var_modlist.append("/W")
+                else:
+                    var_modlist.append("/R")
+                stmt = self.batch_replace(stmt, [("CV_PROP_RW", ""), ("CV_PROP_W", ""), ("CV_PROP", "")]).strip()
+                if re.search(r"\bstatic\b\s*", stmt):
+                    var_modlist.append("/S")
+                    stmt = re.sub(r"\bstatic\b\s*", "", stmt)
+                if re.search(r"\bconst\b\s*", stmt):
+                    var_modlist.append("/C")
+                    stmt = re.sub(r"\bconst\b\s*", "", stmt)
+                var_list = self.get_var_list(stmt)
                 var_type, var_name1, modlist, argno = self.parse_arg(var_list[0], -1)
                 var_list = [var_name1] + [i.strip() for i in var_list[1:]]
 
